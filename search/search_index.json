{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>CLI - Web - Lambda - PHP Extension</p>"},{"location":"#santa-lang","title":"santa-lang","text":"<p>An functional, C-like programming language for solving Advent of Code puzzles.</p> <p>Influenced by: Rust, Python, Clojure, F#, Scala</p>"},{"location":"#release","title":"Release","text":"Runtime Platform Release CLI Linux/GNU <code>santa-lang-cli-0.0.1-x86_64-unknown-linux-gnu</code> CLI Apple/Darwin <code>santa-lang-cli-0.0.1-x86_64-apple-darwin</code> CLI Docker/x86 <code>ghcr.io/eddmann/santa-lang-cli:0.0.1</code> Web WASM <code>@eddmann/santa-lang-wasm@0.0.1</code> Lambda provided.al2 <code>arn:aws:lambda:eu-west-1:428533468732:layer:santa-lang:9</code> PHP Linux/GNU <code>santa-lang-php-ext-0.0.1-x86_64-linux</code>"},{"location":"#why","title":"Why?","text":"<p>Over the past several years I have been slowly working through the previous Advent of Code calendars. For each calendar I opt to solve the puzzles in a new programming language, to familiarise myself with other ways of understanding and working. However, there comes a time in each calendar that I grow to dislike some aspect of the language. So I had an idea... why not give this whole programming language design a go. That way if I grow to dislike this language, I only have myself to blame!</p> <p>Welcome santa-lang, my programming language designed to help tackle Advent of Code puzzles.</p>"},{"location":"#implementations","title":"Implementations","text":"<p>The language specification and runtime implementation can be seen as two separate concerns; similar to how the Python language has been implemented within CPython/JPython, and ECMAScript within V8/SpiderMonkey. There are two separate implementations of the language (and runner), both of which follow the (informal) specification laid out in this documentation. There is feature parity in regard to the core language, data types and builtin functions. Any solution that is written for one implementation should be executable (without modification) on the other. This is why along with extensive test coverage, each implementation is tested using the full 2022 Advent of Code calendar, to ensure of no regressions.</p>"},{"location":"#typescript","title":"TypeScript","text":"<p>Repository: eddmann/santa-lang-ts</p> <p>This was the initial tree-walking interpreter reference implementation used whilst creating of the language and runner. It allowed for quick exploration of different language constructs, and exercise them with actual Advent of Code problems throughout the 2022 calendar. TypeScript was chosen due to speed of development and minimal friction to try out new ideas. The JavaScript runtime also made it easy to develop the initial CLI, Web and Lambda runtimes; with minimal unique delivery requirements.</p>"},{"location":"#rust","title":"Rust","text":"<p>Repository: eddmann/santa-lang-rs - \u2b50 This is the recommended implementation</p> <p>Taking all the learnings from the TypeScript counterpart, the Rust implementation was built to be a more stable and performant tree-walking interpreter. It was felt that the JavaScript runtime could only reach so much performance, and a lower-level language could unlock more performance gains. Along with performance considerations, during its development there was the addition of a WASM runtime (which aligns with TypeScript's Web counterpart), a PHP extension and a CLI REPL. These features are all unique to the Rust implementation.</p>"},{"location":"builtins/","title":"Builtin Functions","text":"<p>The language trys to follow Python's batteries included motto, where-by all desired functionality is included out of the box. This is achieved by the inclusion of many different builtin functions, allowing you tackle many general-purpose and Advent of Code specific problems. The following builtin functions are available in all runtimes:</p>"},{"location":"builtins/#collection","title":"Collection","text":""},{"location":"builtins/#list","title":"list","text":"<pre><code>list(value)</code></pre> <p>Return the List representation of the given value.</p> ListSetDictionaryStringExclusive RangeInclusive Range <pre><code>list([1, 2, 3])</code></pre> <pre><code>list({1, 2, 3})</code></pre> <p>Ouput is a List of List tuples <code>[key, value]</code>.</p> <pre><code>list(#{1: 2, 3: 4})</code></pre> <pre><code>list(\"ab\")</code></pre> <pre><code>list(1..5)</code></pre> <pre><code>list(1..=5)</code></pre>"},{"location":"builtins/#set","title":"set","text":"<pre><code>set(value)</code></pre> <p>Return the Set representation of the given value.</p> ListSetStringExclusive RangeInclusive Range <pre><code>set([1, 2, 3])</code></pre> <pre><code>set({1, 2, 3})</code></pre> <pre><code>set(\"ab\")</code></pre> <pre><code>set(1..5)</code></pre> <pre><code>set(1..=5)</code></pre>"},{"location":"builtins/#dict","title":"dict","text":"<pre><code>dict(value)</code></pre> <p>Return the Dictionary representation of the given value.</p> ListDictionary <p>Input is a List of List tuples <code>[key, value]</code>.</p> <pre><code>dict([[1, 2], [3, 4]])</code></pre> <pre><code>dict(#{1: 2, 3: 4})</code></pre>"},{"location":"builtins/#get","title":"get","text":"<pre><code>get(index, collection)</code></pre> <p>Get an element within a collection following the indexing rules. If an element can not be found at that index then <code>nil</code> is returned.</p> ListSetDictionaryStringExclusive RangeInclusive RangeUnbounded Range <pre><code>get(1, [1, 2])</code></pre> <pre><code>get(1, {1, 2})</code></pre> <pre><code>get(1, #{1: 2, 3: 4})</code></pre> <pre><code>get(1, \"ab\")</code></pre> <pre><code>get(1, 1..5)</code></pre> <pre><code>get(1, 1..=5)</code></pre> <pre><code>get(1, 0..)</code></pre>"},{"location":"builtins/#size","title":"size","text":"<pre><code>size(collection)</code></pre> <p>Get the size of a collection.</p> ListSetDictionaryStringExclusive RangeInclusive Range <pre><code>size([1, 2])</code></pre> <pre><code>size({1, 2})</code></pre> <pre><code>size(#{1: 2, 3: 4})</code></pre> <pre><code>size(\"ab\")</code></pre> <pre><code>size(1..5)</code></pre> <pre><code>size(1..=5)</code></pre>"},{"location":"builtins/#push","title":"push","text":"<pre><code>push(value, collection)</code></pre> <p>Add a new value to a collection.</p> ListSet <p>The value is appended to the end of the List.</p> <pre><code>push(3, [1, 2])</code></pre> <pre><code>push(3, {1, 2})</code></pre>"},{"location":"builtins/#assoc","title":"assoc","text":"<pre><code>assoc(key, value, collection)</code></pre> <p>Associate the provided key/index with the given value in a collection.</p> ListDictionary <pre><code>assoc(0, 3, [1, 2])</code></pre> <p>If the index is not already present <code>nil</code> values are inserted up to the given index.</p> <pre><code>assoc(1, 1, [])</code></pre> <pre><code>assoc(1, 1, #{1: 2, 3: 4})</code></pre> <pre><code>assoc(0, 1, #{1: 2, 3: 4})</code></pre>"},{"location":"builtins/#update","title":"update","text":"<pre><code>update(key, updater, collection)</code></pre> <p>Update the given index/key of a collection using the supplied pure <code>updater</code> function. The <code>updater</code> function is supplied the current value at the given index/key, if not present <code>nil</code> is supplied.</p> ListDictionary <pre><code>update(0, _ + 1, [1, 2])</code></pre> <p>If the index is not already present <code>nil</code> values are inserted up to the given index.</p> <pre><code>update(1, || 1, [])</code></pre> <pre><code>update(0, || 1, #{})</code></pre> <pre><code>update(1, _ + 1, #{1: 2, 3: 4})</code></pre>"},{"location":"builtins/#update_d","title":"update_d","text":"<pre><code>update_d(key, default, updater, collection)</code></pre> <p>Update the given index/key of a collection using the supplied pure <code>updater</code> function. The <code>updater</code> function is supplied the current value at the given index/key, if not present the default value is supplied.</p> ListDictionary <pre><code>update_d(0, 0, _ + 1, [1, 2])</code></pre> <p>If the index is not already present <code>nil</code> values are inserted up to the given index.</p> <pre><code>update_d(1, 0, _ + 1, [])</code></pre> <pre><code>update_d(0, 0, _ + 1, #{})</code></pre> <pre><code>update_d(1, 0, _ + 1, #{1: 2, 3: 4})</code></pre>"},{"location":"builtins/#map","title":"map","text":"<pre><code>map(mapper, collection)</code></pre> <p>Return a collection with a pure <code>mapper</code> function applied over each element within the given collection.</p> ListSetDictionaryString <pre><code>map(_ + 1, [1, 2])</code></pre> <pre><code>map(_ + 1, {1, 2})</code></pre> <pre><code>map(_ + 1, #{1: 2, 3: 4})</code></pre> <p>The <code>mapper</code> function is suppled both the value and key in the context of a Dictionary.</p> <pre><code>map(|_, k| k + 1, #{1: 2, 3: 4})</code></pre> <p>Each character is considered an element within the mapping. The returned collection is a List.</p> <pre><code>map(_ * 2, \"ab\")</code></pre> <p>Lazy Sequences return another Lazy Sequence, which when resolved will lazily apply the required mapping.</p> Exclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>map(_ + 1, 1..5) |&gt; list</code></pre> <pre><code>map(_ + 1, 1..=5) |&gt; list</code></pre> <pre><code>map(_ + 1, 0..) |&gt; take(3)</code></pre> <pre><code>map(_ + 1, repeat(1)) |&gt; take(3)</code></pre>"},{"location":"builtins/#filter","title":"filter","text":"<pre><code>filter(predicate, collection)</code></pre> <p>Return a collection based on a pure <code>predicate</code> function holding truthy for the given element in a collection.</p> ListSetDictionaryString <pre><code>filter(_ == 1, [1, 2])</code></pre> <pre><code>filter(_ == 1, {1, 2})</code></pre> <pre><code>filter(_ == 2, #{1: 2, 3: 4})</code></pre> <p>The <code>predicate</code> function is suppled both the value and key in the context of a Dictionary.</p> <pre><code>filter(|_, k| k == 3, #{1: 2, 3: 4})</code></pre> <p>Each character is considered an element within the predicate. The returned collection is a List.</p> <pre><code>filter(_ == \"a\", \"ab\")</code></pre> <p>Lazy Sequences return another Lazy Sequence, which when resolved will lazily apply the required filter.</p> Exclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>filter(_ % 2, 1..5) |&gt; list</code></pre> <pre><code>filter(_ % 2, 1..=5) |&gt; list</code></pre> <pre><code>filter(_ % 2, 0..) |&gt; take(3)</code></pre> <pre><code>filter(_ != 2, cycle([1, 2, 3])) |&gt; take(3)</code></pre>"},{"location":"builtins/#each","title":"each","text":"<pre><code>each(side_effect, collection)</code></pre> <p>Apply a side-effecting function over each element in the given collection.</p> ListSetDictionaryString <pre><code>let mut acc = 0;\neach(|v| acc = acc + v, [1, 2]);\nacc;</code></pre> <pre><code>let mut acc = 0;\neach(|v| acc = acc + v, {1, 2});\nacc;</code></pre> <pre><code>let mut acc = 0;\neach(|v| acc = acc + v, #{1: 2, 3: 4});\nacc;</code></pre> <p>The <code>predicate</code> function is suppled both the value and key in the context of a Dictionary.</p> <pre><code>let mut acc = 0;\neach(|_, k| acc = ac + k, #{1: 2, 3: 4});\nacc;</code></pre> <p>Each character is considered an element within the iteration. The returned collection is a List.</p> <pre><code>let mut acc = 0;\neach(|_| acc = acc + 1, \"ab\");\nacc;</code></pre> <p>The function can <code>break</code> which will terminate the collection iteration early.</p> Exclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>let mut acc = 0;\neach(|v| acc = acc + v, 1..5);\nacc;</code></pre> <pre><code>let mut acc = 0;\neach(|v| acc = acc + v, 1..=5);\nacc;</code></pre> <pre><code>let mut acc = 0;\n0.. |&gt; each |v| {\n  if v == 10 { break nil } else { acc = acc + v }\n};\nacc;</code></pre> <pre><code>let mut acc = 0;\niterate(_ + 1, 1) |&gt; each |v| {\n  if v == 10 { break nil } else { acc = acc + v }\n};\nacc;</code></pre>"},{"location":"builtins/#reduce","title":"reduce","text":"<pre><code>reduce(reducer, collection)</code></pre> <p>Apply a pure <code>reducer</code> function over a given collection. The initial accumulator value supplied upon first iteration is the first element in the collection. If the collection is empty then an error is thrown.</p> ListSetDictionaryString <pre><code>reduce(+, [1, 2])</code></pre> <pre><code>reduce(+, {1, 2})</code></pre> <pre><code>reduce(+, #{1: 2, 3: 4})</code></pre> <p>The <code>reducer</code> function is suppled both the value and key in the context of a Dictionary.</p> <pre><code>reduce(|acc, _, k| acc + k, #{1: 2, 3: 4})</code></pre> <p>Each character is considered an element within the reduction. The returned collection is a List.</p> <pre><code>reduce(|acc, ch| ch + acc, \"ab\")</code></pre> <p>The function can <code>break</code> which will terminate the collection iteration early.</p> Exclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>reduce(+, 1..5)</code></pre> <pre><code>reduce(+, 1..=5)</code></pre> <pre><code>0.. |&gt; reduce |acc, v| {\n  if v == 10 { break acc } else { acc + v }\n}</code></pre> <pre><code>iterate(_ + 1, 1) |&gt; reduce |acc, v| {\n  if v == 10 { break acc } else { acc + v }\n}</code></pre>"},{"location":"builtins/#fold","title":"fold","text":"<pre><code>fold(initial, folder, collection)</code></pre> <p>Apply a pure <code>folder</code> function over a given collection. The initial fold receives the first element and the initial value supplied. If the collection is empty then the initial value is returned.</p> ListSetDictionaryString <pre><code>fold(0, +, [1, 2])</code></pre> <pre><code>fold(0, +, {1, 2})</code></pre> <pre><code>fold(0, +, #{1: 2, 3: 4})</code></pre> <p>The <code>folder</code> function is suppled both the value and key in the context of a Dictionary.</p> <pre><code>fold(0, |acc, _, k| acc + k, #{1: 2, 3: 4})</code></pre> <p>Each character is considered an element within the fold. The returned collection is a List.</p> <pre><code>fold(0, _ + 1, \"ab\")</code></pre> <p>The function can <code>break</code> which will terminate the collection iteration early.</p> Exclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>fold(0, +, 1..5)</code></pre> <pre><code>fold(0, +, 1..=5)</code></pre> <pre><code>0.. |&gt; fold (0) |acc, v| {\n  if v == 10 { break acc } else { acc + v }\n}</code></pre> <pre><code>iterate(_ + 1, 1) |&gt; fold (0) |acc, v| {\n  if v == 10 { break acc } else { acc + v }\n}</code></pre>"},{"location":"builtins/#fold_s","title":"fold_s","text":"<pre><code>fold_s(initial, folder, collection)</code></pre> <p>Apply a pure <code>folder</code> function over a given collection, with optional state which is passed along throughout the fold. The accumulated value is a List comprising of the first element being the resulting folded value, and other elements being state you wish to pass on to the next iteration. Upon completion, the extra state is discarded and the folded value is returned. If the collection is empty then the initial value is returned.</p> <pre><code>50..100 |&gt; fold_s(\n  [0, 0, 0],\n  |[acc, x, y], val| [acc + x * y * val, val, val / 2]\n)</code></pre>"},{"location":"builtins/#find","title":"find","text":"<pre><code>find(predicate, collection)</code></pre> <p>Apply a pure <code>predicate</code> function over a given collection, returning the first element where the predicate holds truthy.</p> ListSetDictionaryStringExclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>find(_ % 2, [1, 2])</code></pre> <pre><code>find(_ % 2, {1, 2})</code></pre> <pre><code>find(_ % 2, #{1: 2, 3: 4})</code></pre> <p>The <code>predicate</code> function is suppled both the value and key in the context of a Dictionary.</p> <pre><code>find(|_, k| k % 2, #{1: 2, 3: 4})</code></pre> <p>Each character is considered an element within the predicate. The returned collection is a List.</p> <pre><code>find(_ == \"b\", \"ab\")</code></pre> <pre><code>find(_ % 2, 1..5)</code></pre> <pre><code>find(_ % 2, 1..=5)</code></pre> <pre><code>find(_ % 2, 0..)</code></pre> <pre><code>find(_ % 2, iterate(_ + 1, 1))</code></pre>"},{"location":"builtins/#scan","title":"scan","text":"<pre><code>scan(initial, folder, collection)</code></pre> <p>Return a collection which includes the result of each iteration of folding a pure <code>folder</code> function over each element within the given collection.</p> ListSetDictionaryStringExclusive RangeInclusive Range <pre><code>scan(0, +, [1, 2])</code></pre> <pre><code>scan(0, +, {1, 2})</code></pre> <pre><code>scan(0, +, #{1: 2, 3: 4})</code></pre> <p>The <code>folder</code> function is suppled both the value and key in the context of a Dictionary.</p> <pre><code>scan(0, |acc, _, k| acc + k, #{1: 2, 3: 4})</code></pre> <p>Each character is considered an element within the fold. The returned collection is a List.</p> <pre><code>scan(\"\", +, \"ab\")</code></pre> <pre><code>scan(0, +, 1..5)</code></pre> <pre><code>scan(0, +, 1..=5)</code></pre>"},{"location":"builtins/#flat_map","title":"flat_map","text":"<pre><code>flat_map(mapper, collection)</code></pre> <p>Apply a pure <code>mapper</code> function over a given collection with the resulting mapped List results being flattened into a single List.</p> <pre><code>flat_map(_ * 2, [[1, 2], [3, 4]])</code></pre>"},{"location":"builtins/#filter_map","title":"filter_map","text":"<pre><code>filter_map(mapper, collection)</code></pre> <p>Apply a pure <code>mapper</code> function over a given collection and filter out the mapped values based on them being truthy. This is a convenience function (inspired by Rust) for the common place <code>map(..) |&gt; filter(..)</code> pattern.</p> ListSetDictionaryStringExclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>[1, 2, 3, 4] |&gt; filter_map(|v| if v % 2 { v * 2 })</code></pre> <pre><code>{1, 2, 3, 4} |&gt; filter_map(|v| if v % 2 { v * 2 })</code></pre> <pre><code>#{1: 2, 3: 4} |&gt; filter_map(|v| if v != 2 { v * 2 })</code></pre> <p>The <code>mapper</code> function is suppled both the value and key in the context of a Dictionary.</p> <pre><code>#{1: 2, 3: 4} |&gt; filter_map(|_, k| if k != 1 { k * 2 })</code></pre> <p>Each character is considered an element within the mapping. The returned collection is a List.</p> <pre><code>\"ab\" |&gt; filter_map(|v| if v != \"a\" { v * 2 })</code></pre> <pre><code>1..5\n  |&gt; filter_map(|v| if v % 2 { v * 2 })\n  |&gt; list</code></pre> <pre><code>1..=5\n  |&gt; filter_map(|v| if v % 2 { v * 2 })\n  |&gt; list</code></pre> <pre><code>1..\n  |&gt; filter_map(|v| if v % 2 { v * 2 })\n  |&gt; take(3)</code></pre> <pre><code>iterate(_ + 1, 1)\n  |&gt; filter_map(|v| if v % 2 { v * 2 })\n  |&gt; take(3)</code></pre>"},{"location":"builtins/#find_map","title":"find_map","text":"<pre><code>find_map(mapper, collection)</code></pre> <p>Apply a pure <code>mapper</code> function over a given collection and find the first mapped element where the value returned is truthy. This is a convenience function (inspired by Rust) for the common place <code>map(..) |&gt; find(..)</code> pattern.</p> ListSetDictionaryStringExclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>[1, 2] |&gt; find_map(|v| if v % 2 { v * 2 })</code></pre> <pre><code>{1, 2} |&gt; find_map(|v| if v % 2 { v * 2 })</code></pre> <pre><code>#{1: 2, 3: 4} |&gt; find_map(|v| if v != 2 { v * 2 })</code></pre> <p>The <code>mapper</code> function is suppled both the value and key in the context of a Dictionary.</p> <pre><code>#{1: 2, 3: 4} |&gt; find_map(|_, k| if k != 1 { k * 2 })</code></pre> <p>Each character is considered an element within the mapping. The returned collection is a List.</p> <pre><code>\"ab\" |&gt; find_map(|v| if v != \"a\" { v * 2 })</code></pre> <pre><code>1..5 |&gt; find_map(|v| if v % 2 { v * 2 })</code></pre> <pre><code>1..=5 |&gt; find_map(|v| if v % 2 { v * 2 })</code></pre> <pre><code>1.. |&gt; find_map(|v| if v % 2 { v * 2 })</code></pre> <pre><code>iterate(_ + 1, 1)\n  |&gt; find_map(|v| if v % 2 { v * 2 })</code></pre>"},{"location":"builtins/#count","title":"count","text":"<pre><code>count(predicate, collection)</code></pre> <p>Count the total number of elements where the pure <code>predicate</code> function holds truthy.</p> ListSetDictionaryStringExclusive RangeInclusive Range <pre><code>count(_ % 2, [1, 2, 3, 4])</code></pre> <pre><code>count(_ % 2, {1, 2, 3, 4})</code></pre> <pre><code>count(_ % 2, #{1: 2, 3: 4})</code></pre> <p>The <code>predicate</code> function is suppled both the value and key in the context of a Dictionary.</p> <pre><code>count(|_, k| k % 2, #{1: 2, 3: 4})</code></pre> <p>Each character is considered an element within the predicate. The returned collection is a List.</p> <pre><code>count(_ == \"a\", \"ab\")</code></pre> <pre><code>count(_ % 2, 1..5)</code></pre> <pre><code>count(_ % 2, 1..=5)</code></pre>"},{"location":"builtins/#zip","title":"zip","text":"<pre><code>zip(collection, ..collections)</code></pre> <p>Takes any number of iterables as an argument and aggregates them together producing a List/Lazy Sequence of List tuples. Each List tuple contains elements of all iterables occurring at the same position, stopping when the shortest iterables is exhausted.</p> <pre><code>zip(0.., \"abc\", [1.5, 2.5, 3.5])</code></pre> <pre><code>zip(0.., \"abcdef\", [1.5, 2.5, 3.5])</code></pre> <p>If any of the iterables have a finite size then a List is returned, else a Lazy Sequence is produced.</p> <pre><code>zip(0.., 1..) |&gt; take(3)</code></pre>"},{"location":"builtins/#sum","title":"sum","text":"<pre><code>sum(collection)</code></pre> <p>Sum all the Integer elements within a collection.</p> ListSetDictionaryExclusive RangeInclusive Range <pre><code>sum([1, 2])</code></pre> <pre><code>sum({1, 2})</code></pre> <pre><code>sum(#{1: 2, 3: 4})</code></pre> <pre><code>sum(1..5)</code></pre> <pre><code>sum(1..=5)</code></pre>"},{"location":"builtins/#max","title":"max","text":"<pre><code>max(..values)</code></pre> <p>Find the largest (maximum) element within a collection. The collections can be supplied as a single argument List (containing multiple collections), or as a multi-arity function call.</p> <pre><code>max(1, 2) == max([1, 2])</code></pre> ListSetDictionaryExclusive RangeInclusive Range <pre><code>max([1, 2])</code></pre> <pre><code>max({1, 2})</code></pre> <pre><code>max(#{1: 2, 3: 4})</code></pre> <pre><code>max(1..5)</code></pre> <pre><code>max(1..=5)</code></pre>"},{"location":"builtins/#min","title":"min","text":"<pre><code>min(..values)</code></pre> <p>Find the smallest (minimum) element within a collection. The collections can be supplied as a single argument List (containing multiple collections), or as a multi-arity function call.</p> <pre><code>min(1, 2) == min([1, 2])</code></pre> ListSetDictionaryExclusive RangeInclusive Range <pre><code>min([1, 2])</code></pre> <pre><code>min({1, 2})</code></pre> <pre><code>min(#{1: 2, 3: 4})</code></pre> <pre><code>min(1..5)</code></pre> <pre><code>min(1..=5)</code></pre>"},{"location":"builtins/#skip","title":"skip","text":"<pre><code>skip(total, collection)</code></pre> <p>Skip a number of elements within a collection. If the collection is a Lazy Sequence the skip is applied when the collection is lazily resolved.</p> ListSetExclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>skip(1, [1, 2, 3])</code></pre> <pre><code>skip(1, {1, 2, 3})</code></pre> <pre><code>skip(2, 1..5)</code></pre> <pre><code>skip(2, 1..=5)</code></pre> <pre><code>skip(2, 1..) |&gt; take(3)</code></pre> <pre><code>skip(2, iterate(_ + 1, 1)) |&gt; take(3)</code></pre>"},{"location":"builtins/#take","title":"take","text":"<pre><code>take(total, collection)</code></pre> <p>Take a number of elements from a collection. If the collection is a Lazy Sequence then the collection is resolved with any outstanding operations (<code>map</code>, <code>skip</code> etc.) being applied.</p> ListSetExclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>take(2, [1, 2, 3])</code></pre> <pre><code>take(2, {1, 2, 3})</code></pre> <pre><code>take(2, 1..5)</code></pre> <pre><code>take(2, 1..=5)</code></pre> <pre><code>take(2, 1..)</code></pre> <pre><code>take(2, iterate(_ + 1, 1))</code></pre>"},{"location":"builtins/#sort","title":"sort","text":"<pre><code>sort(comparator, collection)</code></pre> <p>Sort the collection based on a supplied pure <code>comparator</code> function. The comparator function accepts two values (a, b) from the collection and can either return:</p> <p>An Boolean value, with <code>false</code> signifying a &lt; b and <code>true</code> signifying a &gt; b.</p> <pre><code>sort(&gt;, [3, 2, 1])</code></pre> <p>An Integer value, with a negative value signifying a &lt; b, zero signifying a == b, and a positive value signifying a &gt; b.</p> <pre><code>sort(-, [3, 2, 1])</code></pre>"},{"location":"builtins/#reverse","title":"reverse","text":"<pre><code>reverse(collection)</code></pre> <p>Reverse the order of a given List collection.</p> ListStringExclusive RangeInclusive Range <pre><code>reverse([1, 2, 3])</code></pre> <pre><code>reverse(\"abc\")</code></pre> <pre><code>reverse(1..5)</code></pre> <pre><code>reverse(1..=5)</code></pre>"},{"location":"builtins/#repeat","title":"repeat","text":"<pre><code>repeat(value)</code></pre> <p>Generate a Lazy Sequence which repeats the provided value indefinitely.</p> <pre><code>repeat(1) |&gt; take(3)</code></pre>"},{"location":"builtins/#cycle","title":"cycle","text":"<pre><code>cycle(list)</code></pre> <p>Generate a Lazy Sequence which cycles through each element in a List indefinitely, looping back to the start once exhausted.</p> ListString <pre><code>cycle([1, 2, 3]) |&gt; take(4)</code></pre> <p>Each character is considered an element within the Lazy Sequence.</p> <pre><code>cycle(\"abc\") |&gt; take(4)</code></pre>"},{"location":"builtins/#iterate","title":"iterate","text":"<pre><code>iterate(generator, initial)</code></pre> <p>Generate a Lazy Sequence which supplies a provided pure <code>generator</code> function with the previous result (starting with an initial value) to produce the next value in the sequence.</p> <pre><code>iterate(|[a, b]| [b, a + b], [0, 1])\n  |&gt; skip(9)\n  |&gt; take(1)</code></pre> <pre><code>iterate(_ * 2, 1) |&gt; take(5)</code></pre>"},{"location":"builtins/#keys","title":"keys","text":"<pre><code>keys(dictionary)</code></pre> <p>Return the keys in a given Dictionary as a List.</p> <pre><code>keys(#{1: 2, 3: 4})</code></pre>"},{"location":"builtins/#values","title":"values","text":"<pre><code>values(dictionary)</code></pre> <p>Return the values in a given Dictionary as a List.</p> <pre><code>values(#{1: 2, 3: 4})</code></pre>"},{"location":"builtins/#first","title":"first","text":"<pre><code>first(collection)</code></pre> <p>Return the first element within the collection (aka head). If the collection is empty then <code>nil</code> is returned.</p> ListSetStringExclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>first([1, 2])</code></pre> <pre><code>first({1, 2})</code></pre> <p>Each character is considered an element.</p> <pre><code>first(\"ab\")</code></pre> <pre><code>first(1..5)</code></pre> <pre><code>first(1..=5)</code></pre> <pre><code>first(1..)</code></pre> <pre><code>first(iterate(_ + 1, 1))</code></pre>"},{"location":"builtins/#second","title":"second","text":"<pre><code>second(collection)</code></pre> <p>Return the second element within the collection. If the collection does not contain a second element then <code>nil</code> is returned.</p> ListSetStringExclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>second([1, 2])</code></pre> <pre><code>second({1, 2})</code></pre> <p>Each character is considered an element.</p> <pre><code>second(\"ab\")</code></pre> <pre><code>second(1..5)</code></pre> <pre><code>second(1..=5)</code></pre> <pre><code>second(1..)</code></pre> <pre><code>second(iterate(_ + 1, 1))</code></pre>"},{"location":"builtins/#rest","title":"rest","text":"<pre><code>rest(collection)</code></pre> <p>Return the collection with the first element omitted (aka tail). If the collection does not have more than one element then an empty List is returned.</p> ListSetStringExclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>rest([1, 2])</code></pre> <pre><code>rest({1, 2})</code></pre> <p>Each character is considered an element.</p> <pre><code>rest(\"ab\")</code></pre> <pre><code>rest(1..5)</code></pre> <pre><code>rest(1..=5)</code></pre> <pre><code>rest(1..)</code></pre> <pre><code>rest(iterate(_ + 1, 1))</code></pre>"},{"location":"builtins/#union","title":"union","text":"<pre><code>union(..values)</code></pre> <p>Return the elements (as a Set) which are found in any of the provided collections. The collections can be supplied as a single argument List (containing multiple collections), or as a multi-arity function call.</p> <pre><code>union([{1, 2}, [2, 3], 1..4, \"abc\"])</code></pre> <pre><code>union({1, 2}, [2, 3], 1..4, \"abc\")</code></pre>"},{"location":"builtins/#intersection","title":"intersection","text":"<pre><code>intersection(..values)</code></pre> <p>Return the elements (as a Set) which are found in all the provided collections. The collections can be supplied as a single argument List (containing multiple collections), or as a multi-arity function call.</p> <pre><code>intersection([{1, 2}, [2, 3], 1..4])</code></pre> <pre><code>intersection({1, 2}, [2, 3], 1..4)</code></pre>"},{"location":"builtins/#rotate","title":"rotate","text":"<pre><code>rotate(steps, collection)</code></pre> <p>Rotate a given List a number of steps. If the step number is positive the rotation proceed forward, with the last item moving to the start of the List. If the step number is negative the rotation will go backwards, with the first item moving to the end of the List.</p> <pre><code>rotate(1, [1, 2, 3])</code></pre> <pre><code>rotate(-1, [1, 2, 3])</code></pre>"},{"location":"builtins/#chunk","title":"chunk","text":"<pre><code>chunk(size, collection)</code></pre> <p>Split a List into chunks based on a given size. If the List size is not divisible by the chunk size then the last chunk will contain fewer than the desired elements.</p> <pre><code>chunk(2, [1, 2, 3])</code></pre> <pre><code>chunk(2, [1, 2, 3, 4])</code></pre>"},{"location":"builtins/#combinations","title":"combinations","text":"<pre><code>combinations(size, collection)</code></pre> <p>Generate a Lazy Sequence which produces all the possible combinations of a desired number of elements from within a List.</p> <pre><code>combinations(2, [1, 2, 3, 4, 5]) |&gt; list</code></pre> <pre><code>combinations(3, [1, 2, 3, 4, 5]) |&gt; find(|x| sum(x) == 10)</code></pre>"},{"location":"builtins/#includes","title":"includes?","text":"<pre><code>includes?(collection, value)</code></pre> <p>Predicate to assert if a value is present within a given collection, based on equality rules.</p> ListSetStringExclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>includes?([1, 2], 1)</code></pre> <pre><code>includes?({1, 2}, 1)</code></pre> <p>Each character is considered an element.</p> <pre><code>includes?(\"ab\", \"a\")</code></pre> <pre><code>includes?(1..5, 1)</code></pre> <pre><code>includes?(1..=5, 1)</code></pre> <pre><code>includes?(1.., 5)</code></pre> <pre><code>includes?(iterate(_ + 1, 1), 5)</code></pre>"},{"location":"builtins/#excludes","title":"excludes?","text":"<pre><code>excludes?(collection, value)</code></pre> <p>Predicate to assert if a value is not present within a given collection, based on equality rules.</p> ListSetStringExclusive RangeInclusive Range <pre><code>excludes?([1, 2], 3)</code></pre> <pre><code>excludes?({1, 2}, 3)</code></pre> <p>Each character is considered an element.</p> <pre><code>excludes?(\"ab\", \"c\")</code></pre> <pre><code>excludes?(1..5, 6)</code></pre> <pre><code>excludes?(1..=5, 6)</code></pre>"},{"location":"builtins/#any","title":"any?","text":"<pre><code>any?(predicate, collection)</code></pre> <p>Predicate to assert if any value within the collection holds truthy based on the supplied pure <code>predicate</code> function.</p> ListSetStringExclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>any?(_ == 1, [1, 2])</code></pre> <pre><code>any?(_ == 1, {1, 2})</code></pre> <p>Each character is considered an element.</p> <pre><code>any?(_ == \"a\", \"ab\")</code></pre> <pre><code>any?(_ == 1, 1..5)</code></pre> <pre><code>any?(_ == 1, 1..=5)</code></pre> <pre><code>any?(_ == 1, 1..)</code></pre> <pre><code>any?(_ == 1, iterate(_ + 1, 1))</code></pre>"},{"location":"builtins/#all","title":"all?","text":"<pre><code>all?(predicate, collection)</code></pre> <p>Predicate to assert if all values within the collection hold truthy based on the supplied pure <code>predicate</code> function.</p> ListSetStringExclusive RangeInclusive Range <pre><code>all?(_ &gt; 0, [1, 2])</code></pre> <pre><code>all?(_ &gt; 0, {1, 2})</code></pre> <p>Each character is considered an element.</p> <pre><code>all?(_ != \"c\", \"ab\")</code></pre> <pre><code>all?(_ &gt; 0, 1..5)</code></pre> <pre><code>all?(_ &gt; 0, 1..=5)</code></pre>"},{"location":"builtins/#math","title":"Math","text":""},{"location":"builtins/#abs","title":"abs","text":"<pre><code>abs(value)</code></pre> <p>Return the absolute value of a number.</p> IntegerDecimal <pre><code>abs(-1)</code></pre> <pre><code>abs(-1.5)</code></pre>"},{"location":"builtins/#vec_add","title":"vec_add","text":"<pre><code>vec_add(a, b)</code></pre> <p>Sum two Lists together using Vector addition. The resulting List will contain results up to the shortest List's size.</p> <pre><code>vec_add([1, 2], [3, 4])</code></pre> <pre><code>vec_add([1, 2, 3], [4, 5, 6])</code></pre>"},{"location":"builtins/#signum","title":"signum","text":"<pre><code>signum(value)</code></pre> <p>Return the sign (<code>-1, 0, 1</code>) for the given number.</p> IntegerDecimal <pre><code>signum(5)</code></pre> <pre><code>signum(-5.5)</code></pre>"},{"location":"builtins/#bitwise","title":"Bitwise","text":""},{"location":"builtins/#bit_and","title":"bit_and","text":"<pre><code>bit_and(a, b)</code></pre> <p>Return an Integer whose binary representation has a 1 in each bit position for which the corresponding bits of both operands are 1.</p> <pre><code>bit_and(9, 11) // 1001 &amp; 1011</code></pre>"},{"location":"builtins/#bit_or","title":"bit_or","text":"<pre><code>bit_or(a, b)</code></pre> <p>Return an Integer whose binary representation has a 1 in each bit position for which the corresponding bits of either or both operands are 1.</p> <pre><code>bit_or(9, 11) // 1001 | 1011</code></pre>"},{"location":"builtins/#bit_xor","title":"bit_xor","text":"<pre><code>bit_xor(a, b)</code></pre> <p>Return an Integer whose binary representation has a 1 in each bit position for which the corresponding bits of either but not both operands are 1.</p> <pre><code>bit_xor(9, 11) // 1001 ^ 1011</code></pre>"},{"location":"builtins/#bit_shift_left","title":"bit_shift_left","text":"<pre><code>bit_shift_left(value, shift)</code></pre> <p>Return an Integer whose binary representation is the first operand shifted by the specified number of bits to the left.</p> <pre><code>bit_shift_left(1, 3)</code></pre>"},{"location":"builtins/#bit_shift_right","title":"bit_shift_right","text":"<pre><code>bit_shift_right(value, shift)</code></pre> <p>Return an Integer whose binary representation is the first operand shifted by the specified number of bits to the right.</p> <pre><code>bit_shift_right(64, 3)</code></pre>"},{"location":"builtins/#string","title":"String","text":""},{"location":"builtins/#int","title":"int","text":"<pre><code>int(value)</code></pre> <p>Attempt to parse the provided value into an Integer representation.</p> IntegerDecimalStringBoolean <pre><code>int(5)</code></pre> <pre><code>int(-5.5)</code></pre> <pre><code>int(\"5\")</code></pre> <pre><code>int(true)</code></pre> <p>Upon failure to parse the value the Integer <code>0</code> is returned.</p> <pre><code>int(\"invalid\")</code></pre>"},{"location":"builtins/#ints","title":"ints","text":"<pre><code>ints(value)</code></pre> <p>Return all parseable Integer values (as per <code>int</code>) from a String value as a List. If no Integers are found and empty List is returned.</p> <pre><code>ints(\"1,2,3\")</code></pre> <pre><code>ints(\"15a20b35\")</code></pre>"},{"location":"builtins/#lines","title":"lines","text":"<pre><code>lines(value)</code></pre> <p>Split a given String into a List of Strings, seperated on new lines <code>\\n</code>.</p> <pre><code>lines(\"a\\nb\\nc\")</code></pre>"},{"location":"builtins/#split","title":"split","text":"<pre><code>split(seperator, value)</code></pre> <p>Split a given String into a List of Strings, seperated based on the provided value.</p> <pre><code>split(\"-\", \"a-b-c\")</code></pre>"},{"location":"builtins/#regex_match","title":"regex_match","text":"<pre><code>regex_match(pattern, value)</code></pre> <p>Match and capture values from a subject String based on a provided Regular Expression. Captured values are returned as a List of Strings. If no match/capture can be found an empty List is returned.</p> <pre><code>regex_match(\"name: (\\\\w+), age: (\\\\d+)\", \"name: Bob, age: 30\")</code></pre>"},{"location":"builtins/#regex_match_all","title":"regex_match_all","text":"<pre><code>regex_match_all(pattern, value)</code></pre> <p>Match and capture all occurrences from a subject String based on a provided Regular Expression. Captured values are returned as a List of Strings. If no match/capture can be found an empty List is returned.</p> <pre><code>regex_match_all(\"\\\\w+: \\\\w+\", \"name: Bob, age: 30\")</code></pre>"},{"location":"builtins/#miscellaneous","title":"Miscellaneous","text":""},{"location":"builtins/#range","title":"range","text":"<pre><code>range(from, to, step)</code></pre> <p>Generate an Inclusive Range using a custom step value (not the default +1, -1).</p> <pre><code>range(1, 10, 2) |&gt; list</code></pre>"},{"location":"builtins/#id","title":"id","text":"<pre><code>id(value)</code></pre> <p>Return the value passed in as an argument.</p> <pre><code>id(5)</code></pre>"},{"location":"builtins/#memoize","title":"memoize","text":"<pre><code>memoize(function)</code></pre> <p>Return a function which wraps a given pure function memoizing invocation calls for performance. This is a trade-off between space and time complexity.</p> <pre><code>let fibonacci = memoize |n| {\n  if (n &gt; 1) {\n    fibonacci(n - 1) + fibonacci(n - 2)\n  } else {\n    n\n  }\n};\nfibonacci(30)</code></pre>"},{"location":"builtins/#evaluate","title":"evaluate","text":"<pre><code>evaluate(source)</code></pre> <p>Evaluates the provided String expression within a sandbox santa-lang interpreter.</p> <pre><code>evaluate(\"1.. |&gt; filter(_ % 2) |&gt; take(3)\")</code></pre>"},{"location":"builtins/#type","title":"type","text":"<pre><code>type(value)</code></pre> <p>Return the type of the given value as a String.</p> <pre><code>type(1)</code></pre>"},{"location":"cli/","title":"CLI","text":"<p>This runtime provides the ability to access the language/runner via a Command Line Interface (CLI). It includes the following functionality:</p> <ul> <li>Execute a given solution's source file, providing benchmark timing for each defined part.</li> <li>Execute a given solutions source files test suite.</li> <li>Execute a given script source file.</li> <li>(Rust only) Load an interactive REPL environment, which can be used to quickly explore the language.</li> </ul>"},{"location":"cli/#release","title":"Release","text":"Platform Release Linux/GNU <code>santa-lang-cli-0.0.1-x86_64-unknown-linux-gnu</code> Apple/Darwin <code>santa-lang-cli-0.0.1-x86_64-apple-darwin</code> Docker/x86 <code>ghcr.io/eddmann/santa-lang-cli:0.0.1</code> <p>Note: the TypeScript implementation can be accessed via the GitHub repository.</p> <p>The Apple/Darwin release may require you to remove the quarantine flag from the executable: <code>xattr -d com.apple.quarantine santa-lang-cli-*-x86_64-apple-darwin</code></p>"},{"location":"cli/#external-functions","title":"External Functions","text":"<p>The CLI provides three runtime specific functions, these are:</p>"},{"location":"cli/#puts","title":"puts","text":"<pre><code>puts(..value)</code></pre> <p>Prints the supplied values (using their display format) to stdout.</p> <pre><code>puts(\"Hello\", [1, 2.5, true])</code></pre>"},{"location":"cli/#read","title":"read","text":"<pre><code>read(path)</code></pre> <p>Reads the contents of the given path into a String. The path can either be:</p> <ul> <li>A local directory path, absolute or relative to the source file.</li> <li>Based on a <code>http(s)</code> schema being defined; a web URL location.</li> <li>Based on a <code>aoc</code> schema being defined; a specific Advent of Code problem input (i.e. <code>aoc://2015/1</code>).   In this case an external <code>SANTA_CLI_SESSION_TOKEN</code> environment variable must be defined which includes a valid Advent of Code session token.   This can be extracted from the cookie set upon successful login to the platform.</li> </ul> LocalURLAoC <pre><code>read(\"input.txt\")</code></pre> <pre><code>read(\"https://www.example.com/input.txt\")</code></pre> <pre><code>read(\"aoc://2015/1\")</code></pre>"},{"location":"cli/#env","title":"env","text":"<pre><code>env()</code></pre> <p>(REPL only) Prints the current environment's variables</p>"},{"location":"cli/#errors","title":"Errors","text":"<p>If an error occurrs during execution the the program is immediately halted; with the error message and associated call stack trace presented to the user, as shown below:</p> <p></p>"},{"location":"cli/#profiling","title":"Profiling","text":"<p>The Rust-based CLI can be built locally (via a Cargo <code>profile</code> feature flag) with additional flamegraph/pprof CPU profiling output for a given solutions' execution. This can be useful when trying to determine slow areas of a given solution, to improve its overall performance.</p> <p></p>"},{"location":"cli/#example","title":"Example","text":"<p>Below is example output for a successful Advent of Code solution and test execution, using the AoC runner:</p> <p></p> <p>Below is example usage of the in-built CLI REPL environment:</p> <p></p>"},{"location":"examples/","title":"Examples","text":"<p>Over the course of development I have used the language in several different projects:</p>"},{"location":"examples/#advent-of-code-2022","title":"Advent of Code 2022","text":"<p>As documented on my blog, I was able to complete the entire 2022 calendar using the language. All solutions can be found within my GitHub Repository.</p>"},{"location":"examples/#advent-of-code-2018","title":"Advent of Code 2018","text":"<p>During development, I used the 2018 calendar as a test-bed to exercise functionality designed within the language. All solutions can be found within my GitHub Repository.</p>"},{"location":"examples/#secret-santa-2022","title":"Secret Santa 2022","text":"<p>Each year I decide to formulate a weird n' wacky way in which to allocate Secret Santa's for my family. For 2022 I used an AWS Step Function workflow with many different runtimes, one of which was santa-lang. The complete workflow can be seen within my GitHub Repository.</p>"},{"location":"lambda/","title":"Lambda","text":"<p>As an exploration into AWS Lambda and how custom runtimes are built, I decided to provide access to the core language via the AWS Lambda platform. This runtime provides the user with the ability to handle a given Lambda request using behaviour defined in santa-lang. Both the Rust and TypeScript implementation have a Lambda runtime available. This does not expose the Advent of Code runner, and is only primarily concerned with exposing the core language functionality.</p>"},{"location":"lambda/#release","title":"Release","text":"Platform Release provided.al2 <code>arn:aws:lambda:eu-west-1:428533468732:layer:santa-lang:9</code> <p>Note: the TypeScript implementation can be accessed via the GitHub repository.</p>"},{"location":"lambda/#lifecycle","title":"Lifecycle","text":"<p>Both the Lambda request event and context are supplied to the handler section expression in the form of variables, <code>event</code> and <code>context</code> accordingly. The Lambda runtime request/response is implicitly mapped to the languages type system. The handler itself, is resolved based on the filename and section expression label you wish to invoke. For example, <code>fibonacci.handle</code> would be resolved to the source file <code>fibonacci.santa</code>, and within there the defined <code>handle</code> section. The resolved handler is then tasked with performing the desired behaviour, and returning either a String or structured Dictionary result (dependent on the desired Lambda integration).</p> <p>In a similar manor to other Lambda runtimes (i.e. Node), the handler section is the the only part that is evaluated upon each request. Other computation put outside this is shared between requests, hence, any expensive work you wish to carry out up front upon cold start can be placed here. However, mutation should not be relied upon due to the un-determinate nature of when a warm/cold Lambda will be used.</p> <p></p>"},{"location":"lambda/#external-functions","title":"External Functions","text":"<p>The Lambda runtime provides two specific functions, these are:</p>"},{"location":"lambda/#puts","title":"puts","text":"<pre><code>puts(..value)</code></pre> <p>Prints the supplied values (using their display format) to stdout.</p> <pre><code>puts(\"Hello\", [1, 2.5, true])</code></pre>"},{"location":"lambda/#read","title":"read","text":"<pre><code>read(path)</code></pre> <p>Reads the contents of the given path into a String. The path can either be:</p> <ul> <li>A local directory path, absolute or relative to the source file (within the packaged Lambda artifact).</li> <li>Based on a <code>http(s)</code> schema being defined; a web URL location.</li> </ul> LocalURL <pre><code>read(\"input.txt\")</code></pre> <pre><code>read(\"https://www.example.com/input.txt\")</code></pre>"},{"location":"lambda/#errors","title":"Errors","text":"<p>The Lambda runtime follows the error response format laid out in the API specification.</p> Type Reason Runtime.HandlerNotFound Handler source file/section is not found Runtime.InitialisationFailed Unable to parse/evaluate the source file to retrieve the handler section Runtime.EnvNotFound Required enviornment variable (<code>_HANDLER</code>, <code>LAMBDA_TASK_ROOT</code>) is not present Invocation.Error An error occurred during execution of the handler within a Lambda request <p></p>"},{"location":"lambda/#example","title":"Example","text":"<p>Below is an example which documents the use of a handler (with shared function):</p> <pre><code>let fibonacci = |n| {\n  let recur = |x, y, n| {\n    if n &gt; 0 { return recur(y, x + y, n - 1) } else { x }\n  };\n  recur(0, 1, n);\n};\n\nhandle: {\n  let number = event[\"number\"];\n  puts(\"Requested the \" + number + \" number in the fibonacci sequence\");\n  #{\"result\": fibonacci(number)};\n}</code></pre>"},{"location":"language/","title":"Language","text":"<ul> <li>Everything is an expression.</li> <li>Everything is an function (mostly).</li> <li>Semicolons are optional.</li> <li>Block expressions implicitly return the last statement as their result, unless an explicit <code>return</code> is used.</li> </ul> <p>There is a write-up detailing the design decisions that went into creating the language.</p>"},{"location":"language/#types","title":"Types","text":""},{"location":"language/#integer","title":"Integer","text":"<p>Represents Integer values, stored as a 64-bit signed number.</p> <pre><code>let int = 1;\nlet int_with_underscores = 1_000_000;</code></pre>"},{"location":"language/#decimal","title":"Decimal","text":"<p>Represents Decimal values, stored as a 64-bit floating point number (the binary64 type defined in IEEE 754-2008).</p> <pre><code>let dec = 1.5;\nlet dec_with_underscores = 1_000_000.50;</code></pre>"},{"location":"language/#string","title":"String","text":"<p>Represents UTF-8 encoded character sequences, with the ability to escape newlines <code>\\n</code>, tabs <code>\\t</code> and quotes <code>\\\"</code>.</p> <pre><code>let str = \"Hello, world!\";\nlet escaped_str = \"\\\"Hello, world!\\\"\\n\";\nlet str_with_unicode = \"\u2764\ud83c\udf55\";</code></pre>"},{"location":"language/#range","title":"Range","text":""},{"location":"language/#exclusive-range","title":"Exclusive Range","text":"<p>Lazily evaluates the Integer range from a given start value until (but not including) the end value. If the start value is greater than the end value then a -1 step is applied each iteration.</p> <pre><code>let asc_exc_range = 1..5;\nlet desc_exc_range = 2..-2;</code></pre> <pre><code>let until = 5;\nlet exc_range_using_expr = (0 + 1)..until;</code></pre>"},{"location":"language/#inclusive-range","title":"Inclusive Range","text":"<p>Lazily evaluates the Integer range from a given start value until (and including) the end value. If the start value is greater than the end value then a -1 step is applied each iteration.</p> <pre><code>let asc_inc_range = 1..=5;\nlet desc_inc_range = 2..=-2;</code></pre> <pre><code>let to = 5;\nlet inc_range_using_expr = (0 + 1)..=to;</code></pre>"},{"location":"language/#unbounded-range","title":"Unbounded Range","text":"<p>Lazily evaluates an infinite Integer range from a given start value, using +1 step each iteration.</p> <pre><code>let inf_range = 1..;\nlet neg_inf_range = -5..;</code></pre>"},{"location":"language/#collection","title":"Collection","text":"<p>Collections are persistent data-structures, yielding new values upon mutation.</p>"},{"location":"language/#list","title":"List","text":"<p>Represents a sequence of heterogeneous elements in insertion order.</p> <pre><code>let homogeneous_list = [1, 2, 3];\nlet heterogeneous_list = [\"4\", 5.0];</code></pre> <pre><code>let list = [1, 2, 3];\nlist |&gt; push(4); // [1, 2, 3, 4]\nlist; // [1, 2, 3]</code></pre>"},{"location":"language/#set","title":"Set","text":"<p>Represents an unordered collection of unique heterogeneous elements.</p> <pre><code>let homogeneous_set = {1, 2, 2, 3}; // {1, 2, 3}\nlet heterogeneous_set = {\"4\", 5.0, \"4\"}; // {\"4\", 5.0}</code></pre> <pre><code>let set = {1, 2, 3};\nset |&gt; push(4); // {1, 2, 3, 4};\nset; // {1, 2, 3}</code></pre> <p>Most types can be stored within a Set, except for Lazy Sequences and Functions.</p> <pre><code>let set = {1, || 1}; // Error</code></pre>"},{"location":"language/#dictionary","title":"Dictionary","text":"<p>Represents an unordered association between arbitrary keys and values.</p> <pre><code>let homogeneous_dict = #{\"a\": 1, \"b\": 2};\nlet heterogeneous_dict = #{[1]: 1.5, 2: true, homogeneous_dict};</code></pre> <pre><code>let dictionary = #{\"a\": 1};\ndictionary |&gt; assoc(\"a\", 2); // #{\"a\": 2}\ndictionary; // #{\"a\": 1}</code></pre> <p>Most types can be used as Dictionary keys, except for Lazy Sequences and Functions.</p> <pre><code>let attempted_key = || 1;\nlet dictionary = #{attempted_key: \"one\"}; // Error</code></pre>"},{"location":"language/#lazy-sequence","title":"Lazy Sequence","text":"<p>The language supports the concept of Lazy Sequences, which among other benefits, unlock the ability to produce infinite sequences. Both bounded (inclusive, exclusive) and unbounded (infinite) Ranges are examples of an Lazy Sequence. Functions (such as <code>filter</code> and <code>map</code>) are applied only when required, in the example below when we invoke <code>take</code>.</p> <pre><code>1.. |&gt; filter(|n| n % 2 == 0) |&gt; take(5);</code></pre> <p>The sequence is an immutable definition of desired computation and can be shared.</p> <pre><code>let lazy_seq = zip(1.., 2..) |&gt; map(|[x, y]| x * y);\n[\n  lazy_seq |&gt; skip(5) |&gt; first,\n  lazy_seq |&gt; first\n];</code></pre> <p>Their are several other means of generating a Lazy Sequence:</p> <p>Iterate takes a pure function and applies the previous result (starting with an initial value) upon each iteration.</p> <pre><code>iterate(|[a, b]| [b, a + b], [0, 1]) |&gt; find(|[a]| a &gt; 10);</code></pre> <p>Cycle iterates through a List indefinitely, looping back to the start once exhausted.</p> <pre><code>cycle([1, 2, 3]) |&gt; skip(1) |&gt; take(3);</code></pre> <p>Repeat iterates over the same value indefinitely.</p> <pre><code>repeat(\"a\") |&gt; take(3);</code></pre>"},{"location":"language/#truthy-semantics","title":"Truthy Semantics","text":"<p>Values can be evaluated to a Boolean within predicate expressions using the truthy semantic rules below:</p> Type True Integer Not 0 Decimal Not 0.0 String Not empty List Not empty Set Not empty Dictionary Not empty Lazy Sequence Always Function Always"},{"location":"language/#variables","title":"Variables","text":"<p>Variables are declared using let-binding syntax, with names conforming to <code>[a-Z][a-Z0-9_?]+</code>. Bindings are immutable by-default, and can not be reassigned after declaration.</p> <pre><code>let x = 1;\nx = 2; // Variable 'x' is not mutable</code></pre> <p>Variables can be made mutable using the <code>mut</code> keyword, allowing for the binding to be reassigned after declaration.</p> <pre><code>let mut x = 1;\nx = 2;</code></pre>"},{"location":"language/#destructing","title":"Destructing","text":"<p>List collection values can be destructed into desired let-bindings. The <code>_</code> placeholder symbol is used to denote an ignored positional binding. The <code>..</code> rest symbol is used to collect all the remaining elements into a single List let-binding.</p> <pre><code>let [x, y, _, ..z] = [1, 2, 3, 4, 5];\n[x, y, z];</code></pre> <p>Similar to previous let-bindings, these are immutable by-default. Destructed bindings can be made mutable using the <code>mut</code> keyword.</p> <pre><code>let mut [x, y] = [1, 2];\nx = 2;</code></pre>"},{"location":"language/#operators","title":"Operators","text":"<p>Expected arthritic operations on Integer and Decimal values are available, along with intuitive behaviour on other types.</p> <pre><code>1 + 1; // 2\n1 + 2.5; // 3\n1.5 + 3.25; // 4.75\n1.5 + 1; // 2.5\n\"a\" + \"b\"; // \"ab\"\n[1] + [2, 3]; // [1, 2, 3]\n{1} + {1, 2}; // {1, 2}\n#{1: \"one\"} + #{2: \"two\"}; // #{1: \"one\", 2: \"two}</code></pre> <pre><code>2 - 1; // 1\n2 - 1.5; // 1\n1.5 - 1.25; // 0.25\n1.5 - 1; // 0.50\n{1, 2} - {1}; // {2}</code></pre> <pre><code>2 * 2; // 4\n2.2 * 2; // 4.4\n\"a\" * 3; // \"aaa\"\n[\"a\"] * 2; // [\"a\", \"a\"]</code></pre> <pre><code>5 / 2; // 2\n5 / 2.25; // 2\n5.0 / 2; // 2.5\n5.0 / 2.25; // 2.22</code></pre> <p>Logical OR and AND operations are supported for all values. Non-Boolean values are evaluated based on truthy value semantics.</p> <pre><code>true || false;\n1 || 0;</code></pre> <pre><code>true &amp;&amp; true;\n[1] &amp;&amp; {1};</code></pre> <p>Intuitive equality operations are support for all values.</p> <pre><code>1 == 1;\n1.5 == 1.5;\n\"a\" == \"a\";\ntrue == true;\n[1, 2, 3] == [1, 2, 3];\n{1, 2, 3} == {1, 2, 3};\n#{\"a\": 1} == #{\"a\": 1};</code></pre> <pre><code>1 != 2;\n1.5 != 2.0;\n\"a\" != \"b\";\ntrue != false;\n[1, 2, 3] != [1, 2, 3, 4]\n{1, 2, 3} != {1, 2, 3, 4};\n#{\"a\": 1} != #{\"b\": 2};</code></pre>"},{"location":"language/#indexing","title":"Indexing","text":""},{"location":"language/#list_1","title":"List","text":"<p>List indexing is zero-based, with the ability to index from the start (positive index) and end (negative index) of a sequence. If an element is not found at the given index <code>nil</code> is returned.</p> <pre><code>let list = [1, 2, 3, 4];\n\nlist[0]; // 1\nlist[-1]; // 4\nlist[4]; // nil\nlist[-5]; // nil</code></pre> <p>List slices can be achieved by-way of inclusive/exclusive range indexing.</p> <pre><code>let list = [1, 2, 3, 4];\n\nlist[1..2]; // [2]\nlist[1..=2]; // [2, 3]\nlist[1..=-1]; // [2, 1, 4]</code></pre>"},{"location":"language/#dictionary_1","title":"Dictionary","text":"<p>Dictionary values can be found via their associated key. If a Dictionary key is not present within the collection <code>nil</code> is returned.</p> <pre><code>let dictionary = #{\"a\": 1, \"b\": 2};\n\ndictionary[\"a\"]; // 1\ndictionary[\"c\"]; // nil</code></pre>"},{"location":"language/#string_1","title":"String","text":"<p>String indexing follows much of the same semantics as List indexing, with elements instead being UTF-8 characters. The returned element is the single UTF-8 character as represented as a String.</p> <pre><code>let str = \"hello\";\n\nstr[0]; // \"h\"\nstr[-1]; // \"o\"\nstr[5]; // nil\nstr[-6]; // nil</code></pre> <p>String slices can be achieved by-way of inclusive/exclusive range indexing.</p> <pre><code>let str = \"hello\";\n\nstr[1..2]; // \"e\"\nstr[1..=2]; // \"el\"\nstr[1..=-1]; // \"eho\"</code></pre>"},{"location":"language/#control-structures","title":"Control Structures","text":""},{"location":"language/#if","title":"If","text":"<p>This expression provides a means of performing conditional logic. The supplied predicate expressions is evaluated using truthy value semantics. The expression always returns a value; with <code>nil</code> being returned in the case of the alternative branch not being specified and condition not passing. Following block expression semantics found elsewhere in the language, unless explicitly stated (via the <code>return</code> keyword) the last statement is implicitly returned as the result.</p> <p>Expression without an alternative <code>else</code> branch.</p> <pre><code>if 5 &lt; 10 { 1 } // 1\nif 10 &lt; 5 { 1 } // nil</code></pre> <p>Expression with both a consequence and alternative <code>else</code> branch.</p> <pre><code>if 10 &lt; 5 { 1 } else { 2 }</code></pre> <p>Let-bindings can be declared within the predicate expressions. If the binding is truthy then the variables is bound and available with the consequence branch.</p> <pre><code>if let x = 10 { x } else { 20 }</code></pre>"},{"location":"language/#return","title":"Return","text":"<p>If you wish to return early from a block expression this can be achieved using the <code>return</code> keyword.</p> <pre><code>let ten = |x| {\n  if x &gt; 10 {\n    return \"&gt; 10\"\n  }\n  return \"&lt; 10\"\n}\nten(5);</code></pre>"},{"location":"language/#break","title":"Break","text":"<p>If you wish to break early from a builtin looping construct (i.e <code>fold</code>, <code>reduce</code>, <code>each</code>) this can be achieved with the <code>break</code> keyword. In the example below the reduction will be terminated prematurely and the break value will be returned.</p> <pre><code>0.. |&gt; reduce |acc, value| {\n  if value == 10 {\n    break acc\n  } else {\n    acc + value\n  }\n};</code></pre>"},{"location":"language/#match","title":"Match","text":"<p>The match expression allows you to perform pattern matching on a given subject. If no match is found <code>nil</code> is returned as the expression result.</p> <p>Primitive type values can be matched based on equality rules.</p> <pre><code>let fibonacci = |n| match n {\n  0 { 0 }\n  1 { 1 }\n  n { fibonacci(n - 1) + fibonacci(n - 2) }\n};\nfibonacci(10);</code></pre> <p>List patterns can be matched upon and destructed into let-bindings.</p> <pre><code>let map = |fn, list| match list {\n  [] { [] }\n  [head] { [fn(head)] }\n  [head, ..tail] { [fn(head), ..map(fn, tail)] }\n};\nmap(_ + 1, [1, 2, 3]);</code></pre> <p>Values within Integer ranges can be matched upon.</p> <pre><code>let number = |n| match n {\n  0..5 { \"&lt; 5\" },\n  5..=6 { \"5 or 6\" }\n  7.. { \"&gt;= 7\" }\n};\nnumber(5);</code></pre> <p>An optional predicate expression guard can be defined based on a matched pattern.</p> <pre><code>let filter = |fn, list| match list {\n  [] { [] }\n  [head] if fn(head) { [head] }\n  [head, ..tail] if fn(head) { [head, ..filter(fn, tail)] }\n  [_, ..tail] { filter(fn, tail) }\n};\nfilter(_ != 2, [1, 2, 3]);</code></pre>"},{"location":"language/#sections","title":"Sections","text":"<p>The language has the concept of sections which allow for the definition of named (labeled) expressions. This construct is not explicitly accessible by the program itself, but instead used within the AoC Runner and runtimes to provide a domain-specific structure.</p> <p>An example use-case of this functionality is detailed below, in the form of a AoC solution of which the Runner will process:</p> <pre><code>part_one: {\n  2 + 2\n}\n\ntest: {\n  part_one: 2\n}</code></pre>"},{"location":"language/#functions","title":"Functions","text":"<p>Defining functions (closures) within the language is intentionally very easy and syntactically cheap to do.</p> <p>The most basic means of creating a function is to define one using the pipe syntax.</p> <pre><code>let inc = |x| { x + 1 };\ninc(1);</code></pre> <p>In the event of a single-line block expression, the brackets can be omitted.</p> <pre><code>let inc = |x| x + 1;\ninc(1);</code></pre> <p>Additionally you can partially apply an existing function, which in-turn will create a new function with the remaining parameter arity.</p> <pre><code>let inc = +(1);\ninc(1);</code></pre> <p>This also highlights use of operators being passed around as first-class functions.</p> <p>The placeholder <code>_</code> symbol can also be used to positional omit parameters in which you wish to leave open for the newly created function.</p> <pre><code>let minus = -;\nlet dec = minus(_, 1);\ndec(2);</code></pre> <p>Alternatively binary functions (functions which take two arguments) can be more succinctly written using the following placeholder syntax, borrowed from Scala.</p> <pre><code>let inc = 1 + _;\nlet dec = _ - 1;\ninc(1) == dec(3);</code></pre> <p>All functions which are declared are Closures, and have access to their outer scope variables.</p> <pre><code>let fibonacci_seq = || {\n  let mut [a, b] = [0, 1];\n  || {\n    let aa = a;\n    a = b; b = aa + b;\n    a;\n  };\n}();\nfibonacci_seq();\nfibonacci_seq();</code></pre> <p>Function arguments can be spread from a List, as well as parameters be collected rest into a List.</p> <pre><code>let max = |..xs| xs |&gt; sort(&lt;) |&gt; first;\nmax(..[1, 2, 3]);</code></pre>"},{"location":"language/#recursion","title":"Recursion","text":"<p>Recursive function invocation is supported.</p> <pre><code>let factorial = |n| if n == 0 { 1 } else { n * factorial(n - 1) };\nfactorial(10);</code></pre> <p>Along with Tail-call optimization. To avoid exhausting the call stack, the above <code>factorial</code> function can be rewritten in a tail-recursive form. In this case the runtime will reuse the function call stack frame upon each iteration.</p> <pre><code>let factorial = |n| {\n  let recur = |acc, n| {\n    if n == 0 { acc } else { recur(acc * n, n - 1) }\n  };\n  recur(1, n);\n};\nfactorial(10);</code></pre>"},{"location":"language/#composition","title":"Composition","text":"<p>Functions can be composed together using the <code>&gt;&gt;</code> syntax.</p> <pre><code>let inc_dbl = _ + 1 &gt;&gt; |x| x * x;\ninc_dbl(15);</code></pre> <pre><code>let parse = lines &gt;&gt; map(split(\",\") &gt;&gt; map(int));\nparse(\"1,2\\n3,4\\n5,6\");</code></pre> <p>This is syntactic sugar on top of the following expression.</p> <pre><code>let parse = |x| {\n  map(|line| map(int, split(\",\", line)), lines(x));\n};\nparse(\"1,2\\n3,4\\n5,6\");</code></pre>"},{"location":"language/#threading","title":"Threading","text":"<p>The language leans heavily on functions, and so as to improve readability invocation can be threaded using the <code>|&gt;</code> syntax.</p> <pre><code>1..5 |&gt; map(_ + 1) |&gt; reduce(+);</code></pre> <p>This is syntactic sugar on top of the following expression.</p> <pre><code>reduce(+, map(_ + 1, 1..5));</code></pre>"},{"location":"language/#trailing-lambda","title":"Trailing Lambda","text":"<p>If the last parameter of a function is a function, then a lambda expression passed as the corresponding argument can be placed outside the parentheses. Inspired by Kotlin, this improves readability and enables rich DSLs to be built on-top of language constructs.</p> <pre><code>let mut acc = 1;\n[1, 2, 3] |&gt; each |x| {\n  acc = acc + x * x;\n}\nacc;</code></pre> <pre><code>[1, 2, 3] |&gt; fold(1) |acc, x| {\n  acc + x * x;\n};</code></pre> <p>This is syntactic sugar on top of the following expressions.</p> <pre><code>let mut acc = 1;\neach(|x| { acc = acc + x * x; }, [1, 2, 3]);\nacc;</code></pre> <pre><code>fold(1, |acc, x| acc + x * x, [1, 2, 3]);</code></pre>"},{"location":"language/#infix-invocation","title":"Infix invocation","text":"<p>Functions which accept two arguments (binary) can be called within the infix position like so:</p> <pre><code>[1, 2, 3] `includes?` 3;</code></pre> <p>This is syntactic sugar on top of the following expression.</p> <pre><code>includes?([1, 2, 3], 3);</code></pre>"},{"location":"language/#memoization","title":"Memoization","text":"<p>Referential transparent function calls can be memoized using the built-in higher-order function.</p> <pre><code>let fibonacci = memoize |n| {\n  if (n &gt; 1) {\n    fibonacci(n - 1) + fibonacci(n - 2)\n  } else {\n    n\n  }\n}\nfibonacci(50);</code></pre> <p>This highlights the use of the trailing lambda syntax to produce a rich DSL which looks like a language construct.</p>"},{"location":"language/#builtins","title":"Builtins","text":"<p>There is a suite of builtin functions which help solve many different class of problem.</p>"},{"location":"language/#external","title":"External","text":"<p>The evaluator has the ability to supply external functions to the execution environment which are defined by the delivery runtime. This provides an extensible means of including runtime specific behaviour to the user. It is advised to review your desired runtimes documentation to see what external functions are available.</p>"},{"location":"php-ext/","title":"PHP Extension","text":"<p>This runtime provides the ability to access the language/runner via a native PHP extension. It includes the following functionality:</p> <ul> <li>Execute a given solution's source, providing benchmark timing for each defined part.</li> <li>Execute a given solution's source test suite.</li> <li>Execute a given script source.</li> <li>Execute a arbitrary language expression.</li> </ul> <p>This runtime was built to highlight the power of Rust and explore how to build a PHP extension using ext-php-rs. Using Rust macros and C bindings, it cleanly abstracts away the need to work directly with the Zend API. The resulting values are implicitly converted into expected PHP data types. Errors that occur within the interpreter are relayed back to the PHP runtime via Exceptions.</p>"},{"location":"php-ext/#release","title":"Release","text":"Platform Release Linux/GNU <code>santa-lang-php-ext-0.0.1-x86_64-linux</code>"},{"location":"php-ext/#api","title":"API","text":"<p>With the extension loaded, the interpreter is made accessible via several top-level PHP functions. The Psalm type defintions are presented below:</p> <pre><code>/**\n * @psalm-type RunResult = array{value: string, duration: integer}\n * @psalm-type RunEvaluation = array{part_one?: RunResult, part_two?: RunResult} | RunResult\n * @psalm-return RunEvaluation\n * @throws \\Exception\n */\nfunction santa_aoc_run(string $source, string $cwd = null): array;\n\n/**\n * @psalm-type TestCaseResult = array{expected: string, actual: string; passed: bool}\n * @psalm-type TestCase = array{part_one?: TestCaseResult, part_two?: TestCaseResult}\n * @psalm-return TestCase[]\n * @throws \\Exception\n */\nfunction santa_aoc_test(string $source, string $cwd = null): array;\n\n/** @throws \\Exception */\nfunction santa_evaluate(string $expression, string $cwd = null): string;</code></pre>"},{"location":"php-ext/#external-functions","title":"External Functions","text":"<p>The PHP extension runtime provides two specific functions, these are:</p>"},{"location":"php-ext/#puts","title":"puts","text":"<pre><code>puts(..value)</code></pre> <p>Prints the supplied values (using their display format) to stdout.</p> <pre><code>puts(\"Hello\", [1, 2.5, true])</code></pre>"},{"location":"php-ext/#read","title":"read","text":"<pre><code>read(path)</code></pre> <p>Reads the contents of the given path into a String. The path can either be:</p> <ul> <li>A local directory path, absolute or relative to the current working directory supplied within thr PHP invocation.</li> <li>Based on a <code>http(s)</code> schema being defined; a web URL location.</li> <li>Based on a <code>aoc</code> schema being defined; a specific Advent of Code problem input (i.e. <code>aoc://2015/1</code>).   In this case an external <code>SANTA_CLI_SESSION_TOKEN</code> environment variable must be defined which includes a valid Advent of Code session token.   This can be extracted from the cookie set upon successful login to the platform.</li> </ul> LocalURLAoC <pre><code>read(\"input.txt\")</code></pre> <pre><code>read(\"https://www.example.com/input.txt\")</code></pre> <pre><code>read(\"aoc://2015/1\")</code></pre>"},{"location":"php-ext/#errors","title":"Errors","text":"<p>If an error occurs during execution the the program is immediately halted; with the error message, location and associated call stack trace locations thrown as an PHP Exception.</p> <p></p>"},{"location":"php-ext/#example","title":"Example","text":"<p>Below is an example which documents the use of the three different PHP functions:</p> <pre><code>$solution = file_get_contents(__DIR__ . '/solution.santa');\n\nsanta_aoc_run($solution, cwd: __DIR__);\n\nsanta_aoc_test($solution);\n\nsanta_evaluate('1.. |&gt; filter(_ % 2) |&gt; take(3);');</code></pre>"},{"location":"php-ext/#future-scope","title":"Future scope","text":"<p>Along with providing PHP extension support, there is future scope to expose the interpreter to Python going forward.</p>"},{"location":"runner/","title":"Advent of Code Runner","text":"<p>The language has been designed with the primary goal of aiding in the development of solutions to Advent of Code (AoC) problems. Whilst the core language provides the building blocks to express and evaluate a problem, it is the addition of the AoC Runner that truly helps aid in solution development. Over the many years of AoC problems I have tackled, regardless of language used, I noticed a similar pattern of building up a form of framework for both running and testing each solution. As such, during this languages development, a lot of effort was paid in providing a REPL which catered for a frictionless problem-solving environment.</p> <p>With the aid of Sections, the Runner is able to provide a clear Domain Specific Language (DSL) for the programmer to express and validate the correctness of a solution.</p>"},{"location":"runner/#solution","title":"Solution","text":"<p>The solution source consists of a <code>part_one</code> and/or <code>part_two</code> section. Each section is an expression, which when evaluated (by the desired runtime) returns the answer to the given problem. The solution source is additionally able to define an <code>input</code> section, which will be evaluated and supplied to both <code>part_*</code> sections in the form of a <code>input</code> variable. The Runner also benchmarks each parts execution time and supplies this to the runtime to be presented accordingly.</p> <p>Below is an example solution for solving the first ever AoC problem:</p> <pre><code>input: \"()())\"\n\npart_one: {\n  input |&gt; fold(0) |floor, direction| {\n    if direction == \"(\" { floor + 1 } else { floor - 1 };\n  }\n}\n\npart_two: {\n  zip(1.., input) |&gt; fold(0) |floor, [index, direction]| {\n    let next_floor = if direction == \"(\" { floor + 1 } else { floor - 1 };\n    if next_floor &lt; 0 { break index } else { next_floor };\n  }\n}</code></pre> <p>Note: in this example the input has been statically defined as a String response. Typically, you will see other means of fetching the problem input, for example, via runtime specific implementations of the external <code>read</code> function. If is advised to review your desired runtimes documentation to see what is available.</p>"},{"location":"runner/#testing","title":"Testing","text":"<p>Whilst solving a days problem it is common to be shown a smaller example, in which the expected answer is provided. Along with defining a solution, you are able to provide test cases in the form of <code>test</code> sections. Each test case includes a desired <code>input</code>, alongside a <code>part_one</code> and/or <code>part_two</code> expected result. Upon testing your solution, the Runner will assert the given solutions result to the expected one and return success or failure accordingly. It is upto the runtime to determine how this test results are presented.</p> <pre><code>test: {\n  input: \"()())\"\n  part_one: -1\n  part_two: 5\n}</code></pre>"},{"location":"runner/#example","title":"Example","text":"<p>For completeness, below is the full example solution combining both the solution and test blocks. It also documents use of a runtime-specific external <code>read</code> function.</p> <pre><code>input: read(\"aoc://2015/1\")\n\npart_one: {\n  input |&gt; fold(0) |floor, direction| {\n    if direction == \"(\" { floor + 1 } else { floor - 1 };\n  }\n}\n\npart_two: {\n  zip(1.., input) |&gt; fold(0) |floor, [index, direction]| {\n    let next_floor = if direction == \"(\" { floor + 1 } else { floor - 1 };\n    if next_floor &lt; 0 { break index } else { next_floor };\n  }\n}\n\ntest: {\n  input: \"()())\"\n  part_one: -1\n  part_two: 5\n}</code></pre>"},{"location":"web/","title":"Web","text":"<p>The Web runtime is accessible via WebAssembly (WASM) within the Rust implementation, and bundled JavaScript within the TypeScript implementation. This enables the interpreter to be run within the Browser, Web Worker and Node environments. As expected, the WASM variant is more performant that the JavaScript implementation, due to being compiled to a lower-level language. This variant is also used to execute the runnable examples found within this documentation.</p> <p>Both variants provide the following functionality:</p> <ul> <li>Execute a given solution's source, providing benchmark timing for each defined part.</li> <li>Execute a given solution's source test suite.</li> <li>Execute a given script source.</li> <li>Execute a arbitrary language expression.</li> <li>Ability to define user-land JavaScript functions which are made available to the evaluator as external functions.</li> </ul>"},{"location":"web/#release","title":"Release","text":"Platform Release WASM <code>@eddmann/santa-lang-wasm@0.0.1</code> <p>Note: the TypeScript implementation can be accessed via the GitHub repository.</p>"},{"location":"web/#api","title":"API","text":"<p>Both variants expose the same API, shown below as TypeScript type definitions:</p> <pre><code>type InteropType = string | number | object;\ntype ExternalFunctions = {\n  [name: string]: (arguments: InteropType[]) =&gt; InteropType;\n};\n\ntype Location = { start: number; end: number };\ntype RunErr = { message: string; source: Location; trace: Location[] };\n\ntype RunResult = { value: string; duration: number };\ntype RunEvaluation =\n  | {\n      part_one?: RunResult;\n      part_two?: RunResult;\n    }\n  | RunResult;\n\ntype TestCaseResult = { expected: string; actual: string; passed: boolean };\ntype TestCase = {\n  part_one?: TestCaseResult;\n  part_two?: TestCaseResult;\n};\n\nfunction aoc_run(source: string, js_functions: ExternalFunctions): RunEvaluation | RunErr;\n\nfunction aoc_test(source: string, js_functions: ExternalFunctions): TestCase[] | RunErr;\n\nfunction evaluate(expression: string, js_functions?: ExternalFunctions): string | RunErr;</code></pre>"},{"location":"web/#external-functions","title":"External Functions","text":"<p>Unlike other runtimes which have a select few external functions (defined at the runtime level), the Web variants gives you the power of user-land JavaScript to define and execute desired behaviour. The runtimes implicitly handle the interoperability between the two languages type systems whilst communicating. This provides an extensive platform on which to add additional behaviour and functionality.</p> <p>The defined JavaScript functions must conform to the following type signature:</p> <pre><code>type InteropType = string | number | object;\n\nfunction external_function(arguments: InteropType[]): InteropType;</code></pre> <p>An example external function could be:</p> <pre><code>const puts = (arguments: InteropType[]): InteropType =&gt; console.log(...arguments);</code></pre>"},{"location":"web/#errors","title":"Errors","text":"<p>If an error occurs during execution the the program is immediately halted; with the error message, location and associated call stack trace locations returned as an <code>RunErr</code> object (as detailed above).</p>"},{"location":"web/#example","title":"Example","text":"<p>Below is an example of how the WASM variant can be used within a Web context.</p> <pre><code>import { evaluate } from '@eddmann/santa-lang-wasm';\n\nevaluate('[1, 2, 3] |&gt; map(_ + 1) |&gt; sum');\n\nevaluate('puts(\"Hello, world\")', { puts: console.log.bind(console) });</code></pre>"},{"location":"web/#editor","title":"Editor","text":"<p>Repository: eddmann/santa-lang-editor</p> <p>One of the reasons for providing such a runtime was to create a Web-based code editor which could be used to develop solutions with. Both the Rust (WASM) and TypeScript (JavaScript) variants have been integrated into a version of the editor. The WASM variant however is the preferred version to use.</p> <p></p> <p>In this use-case we are able to map the external <code>puts</code> function to <code>console.log</code>. We are additionally able to map the <code>read</code> function to a synchronous-blocking XMLHttpRequest call (old-school!), which provides access to the <code>http(s)</code> and <code>aoc</code> schema-based input. The evaluation itself is placed inside a Web Worker to ensure that the main JS user-thread is not blocked.</p>"},{"location":"web/#errors_1","title":"Errors","text":"<p>If an error occurrs during execution the the program is immediately halted; with the error message and associated call stack trace presented to the user, as shown below:</p> <p></p>"},{"location":"web/#future-scope","title":"Future scope","text":"<p>Due to the widespread reach of JavaScript and to a lesser extent WASM, there are possibility of bringing the runtime to other platforms in the future. For example, an Electron/Tauri-based desktop application, or exposed within a CloudFlare Worker.</p>"}]}